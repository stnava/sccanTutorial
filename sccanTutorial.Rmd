---
title: "SCCAN tutorial and tests"
output: pdf_document
---
```{r global options, include=FALSE,echo=TRUE}
library( knitr )
library( randomForest )
library( visreg )
library(pheatmap)
library(png)
invisible(suppressMessages(library(ANTsR)))
rootdir<-"/Users/stnava/code/sccanTutorial"
if ( ! file.exists(rootdir) ) {
  dirs<-list.dirs(path = path.expand("~"), full.names = TRUE, recursive = TRUE)
  rootdir<-dirs[ grep('sccanTutorial',dirs)[1] ]
  rootdir<-path.expand(rootdir)
}
opts_knit$set(root.dir=rootdir)
```

# Introduction

## Brief summary
Sparse canonical correlation analysis for neuroimaging (SCCAN) is a general purpose
tool for "two-sided" multiple regression.  This allows one to symmetrically
compare one matrix of data to another and find linear relationships between
them in a low-dimensional space.  SCCAN derives from classic canonical correlation
analysis and also relates to singular value decomposition.  To handle data with $p>>n$,
SCCAN uses high-dimensional regularization methods common in $\ell_1$ regression
and spatial regularization to help ensure the biological plausibility of statistical
maps in medical imaging.  This problem is a difficult optimization ($np$-hard)
and, to improve solution interpetability and stability, SCCAN allows one to
to use prior knowledge to constrain the solution space.

# Examples

Perhaps the best way to understand how to use SCCAN is by running example data.

## Read example data
We read in some neuroimaging and cognitive data below.
```{r readata,fig.width=8, fig.height=4, echo=TRUE, messages=FALSE }
data(aal,package='ANTsR')
gfnl<-list.files(path=rootdir, pattern = glob2rx("pbac*mha"),
  full.names = T,recursive = T) 
ptrainimg<-as.matrix(antsImageRead(gfnl[2],2))
ptestimg<-as.matrix(antsImageRead(gfnl[1],2))
gfnl<-list.files(path=rootdir, pattern = "gmask.nii.gz",
  full.names = T,recursive = T) 
mask<-antsImageRead( gfnl[1], 3 )
afnl<-list.files(path=rootdir, pattern = "aal.nii.gz",
  full.names = T,recursive = T) 
aalimg<-antsImageRead( afnl[1], 3 )
f1<-list.files(path =rootdir, pattern = "pbac_train_cog.csv",
  recursive=TRUE, full.names = TRUE, include.dirs=TRUE )
f2<-list.files(path = rootdir, pattern = "pbac_test_cog.csv",
  recursive=TRUE, full.names = TRUE )
ptraincog<-read.csv(f1)
ptestcog<-read.csv(f2)
```
We already divided the dataset into two different groups - one for testing and 
one for training.  

## Sparse regression

Use sccan to find brain regions relating to age.  We impose a "cluster
threshold" regularization to prevent isolated voxels from appearing in
the solution.  We will also compare the results in training with that
in testing as a function of spareseness.
```{r sparreg,fig.width=8, fig.height=4, echo=TRUE, messages=FALSE }
agemat<-matrix( ptraincog$age, ncol=1)
paramsearch<-c(1:10)/(-100.0)
paramsearchcorrs<-rep(0,length(paramsearch))
paramsearchpreds<-rep(0,length(paramsearch))
ct<-1
for ( sp in paramsearch ) {
  ageresult<-sparseDecom2( inmatrix=list(ptrainimg,agemat), its=8, mycoption=1,
    sparseness=c(sp,0.9), inmask=c(mask,NA),nvecs=2, cthresh=c(50,0))
  # convert output images to matrix so we can validate in test data
  ccamat<-imageListToMatrix( ageresult$eig1, mask )
  agepred<-ptrainimg %*% t(ccamat)
  paramsearchcorrs[ct]<-cor( agepred[,1],  ptraincog$age )
  agepred<-ptestimg %*% t(ccamat)
  paramsearchpreds[ct]<-cor( agepred[,1],  ptestcog$age )
  ct<-ct+1
  }
mydf<-data.frame( sparseness=paramsearch, trainCorrs=paramsearchcorrs, 
  testCorrs=paramsearchpreds )
mdl1<-lm( trainCorrs ~ stats::poly(sparseness,4), data=mydf ) 
mdl2<-lm( testCorrs ~ stats::poly(sparseness,4) , data=mydf ) 
visreg(mdl1)
visreg(mdl2)
```

## SCCAN with prior initialization

Use SCCAN to find brain regions relating to language.
We initialize with left hemisphere regions.

```{r sparreginit,fig.width=8, fig.height=4, echo=TRUE, messages=FALSE }
langmat<-cbind(  ptraincog$speech_adj, ptraincog$writing_adj, 
                 ptraincog$semantic_adj, ptraincog$reading_adj,
                 ptraincog$naming_adj )
colnames(langmat)<-c("speech","writing","semantic","reading","naming")
langmat2<-cbind( ptestcog$speech_adj, ptestcog$writing_adj, 
                 ptestcog$semantic_adj, ptestcog$reading_adj,
                 ptestcog$naming_adj )
# langmat<-residuals(lm(langmat~ptraincog$mmse+ptraincog$age))
labels<-c(13,81,39,79)
print(aal$label_name[labels])
initmat<-matrix( rep(0,sum(mask==1)*length(labels)), nrow=length(labels) )
# fill the matrix with the aal region locations
for ( i in 1:length(labels) ) {
  vec<-( aalimg[ mask == 1 ] == labels[i] )
  vec[ vec > 0]<-vec[ vec > 0]+rnorm(sum(vec>0))*0.5
  initmat[i,]<-vec
}
ccainit<-initializeEigenanatomy( initmat, mask )
pwsearch<-c(40,20,10)
langfn<-rep("",length(pwsearch))
langfn2<-rep("",length(pwsearch))
ct<-1
for ( pw in pwsearch ) {
langresult<-sparseDecom2( inmatrix=list(ptrainimg,langmat), its=6, mycoption=1,
  sparseness=c(sp,-0.9), inmask=c(mask,NA),nvecs=length(labels), cthresh=c(50,0), 
  initializationList=ccainit$initlist, priorWeight=pw/100, smooth=0.5, ell1=-10 )
ccamat<-imageListToMatrix( langresult$eig1, mask )
langpred<-ptrainimg %*% t(ccamat)
colnames(langpred)<-paste("GM",c(1:ncol(langpred)),sep='')
cogpred<-langmat %*% data.matrix( langresult$eig2 )
mydf<-data.frame( cogpred, langpred )
myform<-as.formula( "Variate000~GM1+GM2+GM3+GM4" )
mdltrain<-lm( myform, data=mydf )
langpred<-ptestimg %*% t(ccamat)
colnames(langpred)<-paste("GM",c(1:ncol(langpred)),sep='')
cogpred<-langmat2 %*% data.matrix( langresult$eig2 )
mydf<-data.frame( cogpred, langpred )
print(cor.test( mydf$Variate000 ,predict(mdltrain,newdata=mydf)))
for ( i in 1:length(labels) )
  print( paste( "Dice: ",aal$label_name[labels[i]],
         sum( abs(ccamat[i,]) > 0 & initmat[i,] > 0 ) /
         sum( abs(ccamat[i,]) > 0 | initmat[i,] > 0 ) ) )
for ( x in langresult$eig1 ) {
  x[ mask == 1 ]<-abs( x[ mask == 1 ] )
  x[ mask == 1 ]<-x[ mask == 1 ]/max( x[ mask == 1 ] )
}
mycolors<-c("red","green","blue","yellow")
langfn[ct]<-paste(rootdir,'/figures/langSCCANRegression',pw,'.jpg',sep='')
langfn2[ct]<-paste(rootdir,'/figures/langSCCANRegression',pw,'.png',sep='')
plotANTsImage( mask, functional=(langresult$eig1), threshold='0.25x1',
  slices="12x50x1",color=mycolors,outname=langfn[ct] )
# cnt<-getCentroids( ntwkimage, clustparam = 100 )
brain<-renderSurfaceFunction( surfimg =list( aalimg ) , alphasurf=0.1 ,
  funcimg=langresult$eig1, smoothsval = 1.5, mycol=mycolors )
id<-par3d("userMatrix")
rid<-rotate3d( id , -pi/2, 1, 0, 0 )
rid2<-rotate3d( id , pi/2, 0, 0, 1 )
rid3<-rotate3d( id , -pi/2, 0, 0, 1 )
par3d(userMatrix = id ) 
dd<-make3ViewPNG(  rid, id, rid2, paste(rootdir,'/figures/langSCCANRegression',pw,sep='') )
par3d(userMatrix = id ) 
ct<-ct+1
}
```
Strong prior

![Strong prior](`r langfn[1]`)

![Strong prior 3D](`r langfn2[1]`)

Medium prior

![Medium prior](`r langfn[2]`)

![Medium prior 3D](`r langfn2[2]`)

Weak prior

![Weak prior](`r langfn[3]`)

![Weak prior 3D](`r langfn2[3]`)

## Identifying the anatomical network

The best results are initialized by the prior but, in the end, 
drift away from that initialization.  Where in the brain do the solution 
vectors end up?


```{r aallabel}
ccaanat<-list()
for ( img in langresult$eig1 ) {
  nzind<-img[ mask == 1 ] > 0 
  aalvals<-aalimg[ mask == 1 ][ nzind ]
  ccaanat<-lappend( ccaanat, aalvals )
}
ccaanat<-unlist( ccaanat )
anatcount<-hist(ccaanat,breaks=0:100)$count
anatcount[ anatcount < 0.8*max(anatcount) ]<-0
anatcount<-which( anatcount > 0 )
ccaaal<-aal$label_name[anatcount]
```
The SCCAN predictors include: `r ccaaal`.

How much of the known network do we actually find?


## Associating classes to SCCAN predictors

Recalling: CCA maximizes $PearsonCorrelation( XW^T, ZY^T )$, 
we can study matrix $Y$ which contrasts or combines columns of the cognition/design matrix.

```{r sccanpredictorclass}
rownames(langresult$eig2)<-colnames(langmat)
temp<-(langresult$eig2)
temp[ abs(langresult$eig2) < 0.03 ]<-0
```

```{r sccanpredictorclass2}
pheatmap(temp)
```


## Sparse regression with nuisance variables

Often, we want to control for the presence of nuisance variables.
As usual, there are several options:  (1) control after you do 
dimensionality reduction;  (2) orthogonalize the predictors; 
(3) FIXME ...


## Predicting the full cognitive battery from the neuroimaging data

Can the neuroimaging data predict the full cognitive battery?

```{r mvarpred,fig.width=8, fig.height=4, echo=TRUE, messages=FALSE }
# use cca to transform cortical signal to the cognitive battery 
predictedBattery<-data.frame( vox=ptrainimg %*% t(ccamat) %*% t(langresult$eig2) )
print(cor(langmat,predictedBattery))
predictedBattery<-data.frame( vox=ptestimg %*% t(ccamat) %*% t(langresult$eig2) )
print(cor(langmat2,predictedBattery))
```
